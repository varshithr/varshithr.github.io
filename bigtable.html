<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bigtable Visual Deep Dive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .bigtable-cell {
            min-height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            transition: all 0.3s ease;
            font-size: 0.75rem;
            line-height: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .header-cell {
            background-color: #1e3a8a; /* Dark Blue */
            color: white;
            font-weight: 600;
            border: 1px solid #102e70;
            text-align: center;
        }
        .rowkey-cell {
            background-color: #3b82f6; /* Blue */
            color: white;
            font-weight: 700;
            text-align: left;
            padding-left: 1rem;
            cursor: pointer;
        }
        .data-cell {
            background-color: #ffffff;
            color: #1f2937;
            border: 1px solid #e5e7eb;
            font-size: 0.875rem;
            cursor: pointer;
        }
        .sparse-cell {
            background-color: #f3f4f6;
            color: #9ca3af;
            border: 1px dashed #d1d5db;
            font-style: italic;
            cursor: default;
        }
        .hotspot-ring {
            box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.5); /* Red Ring */
        }
        .range-highlight {
            background-color: #d1fae5 !important; /* Light Green */
            font-weight: 600;
        }
        /* Style for the new replication tab */
        .replication-cell {
             background-color: #fef3c7; /* Yellow for primary/replica contrast */
             color: #92400e;
             font-weight: 500;
        }
        .consistency-cell {
             background-color: #dbeafe; /* Light blue for consistency model */
             color: #1e40af;
             font-weight: 600;
        }
    </style>
    <script>
        // Global State
        const state = {
            currentTab: 'table', 
            message: "Click a concept tab above to explore Bigtable's design.",
        };

        // Core Concepts Data
        const concepts = {
            table: {
                title: "Bigtable: The Sparse Table",
                description: "Bigtable is a sparse, multi-dimensional map. Unlike traditional relational tables, a column only takes up space if a row actually uses it.",
                headers: ["Row Key", "CF:colA (Family:Data)", "CF:colB (Family:Settings)", "CF_TS:Temp (Family:Time Series)"],
                rows: [
                    { key: "User001#Post100", data: ["Hello world", "config=true", "25.0@1719234000"] },
                    { key: "User002#Post101", data: ["Data Science Report", "config=false", ""] },
                    { key: "User001#Post099", data: ["", "", "24.5@1719233400"] },
                    { key: "User003#Log456", data: ["", "status=OK", ""] },
                ]
            },
            rowKey: {
                title: "The Power of the Row Key (Lexicographical Sorting)",
                description: "Rows are sorted like words in a dictionary. This is crucial for fast 'Range Reads.' Note how 'User001#Post100' is separated from 'User001#Post099' because 'Post099' comes before 'Post100' alphabetically.",
                headers: ["Row Key (Sorted)", "Data"],
                rows: [
                    { key: "User001#Post099", data: ["Version 2"] },
                    { key: "User001#Post100", data: ["Version 1"] },
                    { key: "User002#Post101", data: ["Version 3"] },
                    { key: "User003#Log456", data: ["Version 4"] },
                ]
            },
            hotspot: {
                title: "Avoiding Hotspots (Sequential Keys)",
                description: "A Bad Design uses sequential keys, causing all writes to hit the same small tablet (server) leading to a bottleneck (hotspot).",
                headers: ["Row Key (Bad)", "Data", "Tablet Node"],
                rows: [
                    { key: "20250101#00:00:01", data: ["Write 1"], node: "Tablet A (Hot!)" },
                    { key: "20250101#00:00:02", data: ["Write 2"], node: "Tablet A (Hot!)" },
                    { key: "20250101#00:00:03", data: ["Write 3"], node: "Tablet A (Hot!)" },
                    { key: "20250101#00:00:04", data: ["Write 4"], node: "Tablet A (Hot!)" },
                    { key: "20250102#00:00:01", data: ["Write 5"], node: "Tablet B" },
                    { key: "20250102#00:00:02", data: ["Write 6"], node: "Tablet B" },
                ]
            },
            reverseTs: {
                title: "Reverse Timestamps for Newest-First Reads",
                description: "To get the latest data first, you prepend a high-cardinality ID with a **Reverse Timestamp** (`Long.MAX_VALUE - timestamp`). This makes new data sort before old data.",
                headers: ["Row Key (Best)", "Value", "Sort Order"],
                rows: [
                    // MAX_VALUE - TS (Newest first)
                    { key: "SensorXYZ#9223372036854775807", data: ["28.5 C"], order: "Latest Reading" }, 
                    { key: "SensorXYZ#9223372036854775806", data: ["28.4 C"], order: "Next Latest" },
                    { key: "SensorXYZ#9223372036854775805", data: ["28.0 C"], order: "Older Reading" },
                    { key: "SensorABC#9223372036854775807", data: ["15.1 V"], order: "Other Sensor" },
                ]
            },
            colFamilies: {
                title: "Column Families for Locality (The Disk Grouping)",
                description: "Column Families (CFs) are physical groupings of data. Columns in the same CF are stored together on disk, making reads across them very fast. Columns in different CFs are stored separately.",
                headers: ["Row Key", "CF_USER:Name", "CF_PROFILE:Bio", "CF_POSTS:Title"],
                rows: [
                    { key: "User900", data: ["Alice", "Loves Bigtable", "Post A"] },
                    { key: "User901", data: ["Bob", "Data Architect", "Post B"] },
                    { key: "User902", data: ["", "Casual User", "Post C"] },
                ]
            },
            denormalization: {
                title: "The No-Join Rule (Denormalization)",
                description: "Bigtable is optimized for scale and low-latency access by **Row Key**â€”it does not support joins. Related data must be denormalized (duplicated) across multiple row keys to support different query patterns.",
                headers: ["Row Key", "Data Stored", "Query Type Served"],
                rows: [
                    { key: "User#123", data: ["Profile: Alice", "Region: US"], purpose: "Primary Profile Lookup" },
                    { key: "User#123#Post#1", data: ["Post Content: Hello World"], purpose: "Full Timeline Scan" },
                    { key: "Region#US#User#123", data: ["Profile: Alice, Region: US"], purpose: "Secondary Index (Geographic Query)" },
                    { key: "Post#1#Comments", data: ["Comment 1, Comment 2"], purpose: "Fan-out/Joined Data" },
                ]
            },
            // NEW CONCEPT 7: Replication and Consistency
            replication: {
                title: "Replication & Consistency (High Availability)",
                description: "Bigtable uses replication across multiple zones (clusters). Writes go to the primary, and are asynchronously replicated. Reads from any replica are eventually consistent.",
                headers: ["Write Operation", "Zone A (Primary)", "Zone B (Replica)", "Read Consistency"],
                rows: [
                    { key: "Write: Sensor#1 Data", data: ["Received & Acknowledged (T1)", "Pending Replication", "Eventual"] },
                    { key: "Write: Sensor#2 Data", data: ["Received & Acknowledged (T2)", "Replication in Progress (T1)", "Eventual"] },
                    { key: "Read: Sensor#1 Data", data: ["Returns T1 (Latest)", "Might return T0 (Stale)", "Eventual"] },
                    { key: "Failover Event", data: ["Zone A Offline", "Promoted to Primary (T2)", "Available"] },
                ]
            },
            // NEW CONCEPT 8: Pre-splitting
            splits: {
                title: "Split Keys (Pre-splitting for Immediate Distribution)",
                description: "You can define Split Keys during table creation to immediately distribute the data across multiple tablet servers, ensuring balanced load from the first write.",
                headers: ["Row Key Range Start", "Row Key Range End", "Assigned Tablet"],
                rows: [
                    { key: "(Start of Table)", data: ["A0000", "Tablet 1 / Server A"] },
                    { key: "A0000", data: ["F0000", "Tablet 2 / Server B"] },
                    { key: "F0000", data: ["M0000", "Tablet 3 / Server C"] },
                    { key: "M0000", data: ["Z9999", "Tablet 4 / Server D"] },
                    { key: "Z9999", data: ["(End of Table)", "Tablet 5 / Server E"] },
                ]
            }
        };

        /**
         * Converts the global state into HTML and updates the DOM.
         */
        const render = () => {
            const container = document.getElementById('table-container');
            const messageBar = document.getElementById('message-bar');
            const tabButtons = document.querySelectorAll('.tab-button');

            // 1. Update Tabs
            tabButtons.forEach(btn => {
                btn.classList.remove('bg-blue-600', 'text-white');
                btn.classList.add('bg-white', 'text-blue-600', 'hover:bg-blue-50');
                if (btn.dataset.tab === state.currentTab) {
                    btn.classList.remove('bg-white', 'text-blue-600', 'hover:bg-blue-50');
                    btn.classList.add('bg-blue-600', 'text-white', 'shadow-lg');
                }
            });

            // 2. Update Message Bar
            messageBar.innerHTML = `<span class="font-bold">${concepts[state.currentTab].title}</span>: ${concepts[state.currentTab].description}`;

            // 3. Generate Table HTML
            const currentConcept = concepts[state.currentTab];
            let html = `<div class="overflow-x-auto shadow-xl rounded-xl">`;
            // Dynamic grid layout: 180px for Row Key, rest split evenly
            html += `<div class="grid" style="grid-template-columns: 180px repeat(${currentConcept.headers.length - 1}, 1fr);">`;

            // Headers
            currentConcept.headers.forEach(header => {
                html += `<div class="header-cell h-12 flex items-center justify-center">${header}</div>`;
            });

            // Rows
            currentConcept.rows.forEach((row, rowIndex) => {
                // Row Key Cell
                let rowKeyClasses = 'rowkey-cell h-16';
                let dataKeyClasses = 'data-cell h-16';

                // Add special classes based on concept for visual effect
                if (state.currentTab === 'hotspot' && rowIndex < 4) {
                    rowKeyClasses += ' hotspot-ring bg-red-500 hover:bg-red-600';
                }
                if (state.currentTab === 'rowKey' || state.currentTab === 'denormalization') {
                     // Highlight the range for User001/User#123
                    if (row.key.startsWith('User001') || row.key.startsWith('User#123')) {
                         rowKeyClasses += ' range-highlight bg-green-200 text-green-800';
                         dataKeyClasses += ' range-highlight';
                    }
                }
                
                html += `<div class="${rowKeyClasses}" title="Row Key: ${row.key}">${row.key}</div>`;

                // Data Cells
                currentConcept.headers.slice(1).forEach((header, colIndex) => {
                    const data = row.data[colIndex];
                    let cellContent = data;
                    let cellClasses = dataKeyClasses;

                    if (!data) {
                        cellContent = state.currentTab === 'table' ? 'â€” SPARSE â€”' : '';
                        cellClasses = 'sparse-cell h-16';
                    }
                    
                    // Specific styling/content overrides for new tabs
                    if (state.currentTab === 'hotspot' && colIndex === 1) {
                        cellContent = row.node;
                    }
                    if (state.currentTab === 'reverseTs' && colIndex === 1) {
                        cellContent = row.order;
                    }
                    if (state.currentTab === 'denormalization' && colIndex === 1) {
                        cellContent = row.purpose;
                    }
                    if (state.currentTab === 'replication') {
                        cellClasses = (colIndex === 0) ? 'replication-cell h-16 bg-yellow-200' : 
                                      (colIndex === 1) ? 'replication-cell h-16 bg-yellow-100' :
                                      'consistency-cell h-16';
                    }
                    if (state.currentTab === 'splits') {
                        cellClasses = (colIndex === 0) ? 'data-cell h-16' : 
                                      'data-cell h-16 bg-blue-50';
                    }
                    
                    html += `<div class="${cellClasses}" title="${header}: ${data}">${cellContent}</div>`;
                });
            });

            html += `</div></div>`;
            container.innerHTML = html;
        };

        /**
         * Switches the active concept tab.
         * @param {string} tabName 
         */
        const switchTab = (tabName) => {
            state.currentTab = tabName;
            render();
        };

        // Initial setup and event listeners
        window.onload = () => {
            // Set up tab listeners
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => switchTab(button.dataset.tab));
            });

            // Start with the 'table' tab
            render();
        };
    </script>
</head>
<body class="p-8">
    <a href="index.html" class="text-gray-600 hover:text-blue-600 hover:underline font-semibold mb-6 inline-block">&larr; Back to Home</a>
    <h1 class="text-4xl font-extrabold text-gray-800 mb-6 flex items-center">
        <svg class="w-8 h-8 mr-3 text-blue-600" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4zm5 9a1 1 0 10-2 0 1 1 0 002 0zM7 5a1 1 0 00-1 1v4a1 1 0 001 1h6a1 1 0 001-1V6a1 1 0 00-1-1H7z" clip-rule="evenodd"></path></svg>
        Bigtable Schema Design Essentials
    </h1>
    <p class="text-lg text-gray-600 mb-8">Click on the tabs below to explore the core concepts that define an efficient Bigtable schema.</p>

    <!-- Tab Navigation -->
    <div class="flex flex-wrap space-x-4 space-y-2 mb-8">
        <button data-tab="table" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            1. Sparse Table Structure
        </button>
        <button data-tab="rowKey" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            2. Row Key Sorting & Range Read
        </button>
        <button data-tab="hotspot" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            3. Hotspotting (What to AVOID)
        </button>
        <button data-tab="reverseTs" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            4. Reverse Timestamps (Best Practice)
        </button>
        <button data-tab="colFamilies" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            5. Column Families (Locality)
        </button>
        <button data-tab="denormalization" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            6. Denormalization (No-Join Rule)
        </button>
        <button data-tab="replication" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            7. Replication & Consistency
        </button>
        <button data-tab="splits" class="tab-button py-2 px-4 rounded-lg font-semibold border border-blue-600 transition duration-150 ease-in-out">
            8. Split Keys (Pre-splitting)
        </button>
    </div>

    <!-- Explanation Bar -->
    <div id="message-bar" class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-4 mb-8 rounded-md shadow-md">
        <!-- Message will be populated by JS -->
    </div>

    <!-- Bigtable Visualizer Container -->
    <div id="table-container" class="mt-8">
        <!-- Visual table will be generated here -->
    </div>
</body>
</html>
