<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idempotency Retries Answers</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #F0F4F8;
            color: #1E293B;
        }
        .gradient-text {
            background: linear-gradient(90deg, #58508d, #bc5090);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .content {
            background-color: white;
            border-radius: 0.75rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
            margin-top: 2rem;
        }
        .content h1 {
            font-size: 2.5rem;
            font-weight: 900;
            margin-bottom: 1rem;
            color: #1E293B;
        }
        .content h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #1E293B;
            border-bottom: 2px solid #E5E7EB;
            padding-bottom: 0.5rem;
        }
        .content h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #1E293B;
        }
        .content h4 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: #1E293B;
        }
        .content p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        .content ul, .content ol {
            margin-bottom: 1rem;
            padding-left: 2rem;
        }
        .content li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }
        .content code {
            background-color: #F3F4F6;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .content pre {
            background-color: #1E293B;
            color: #F0F4F8;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin-bottom: 1rem;
        }
        .content pre code {
            background-color: transparent;
            padding: 0;
            color: inherit;
        }
        .content blockquote {
            border-left: 4px solid #58508d;
            padding-left: 1rem;
            margin-left: 0;
            margin-bottom: 1rem;
            color: #4B5563;
            font-style: italic;
        }
        .content table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1rem;
        }
        .content th {
            background-color: #F3F4F6;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            border: 1px solid #E5E7EB;
        }
        .content td {
            padding: 0.75rem;
            border: 1px solid #E5E7EB;
        }
        .content tr:nth-child(even) {
            background-color: #F9FAFB;
        }
        .content a {
            color: #58508d;
            text-decoration: underline;
        }
        .content a:hover {
            color: #bc5090;
        }
        .content hr {
            border: none;
            border-top: 2px solid #E5E7EB;
            margin: 2rem 0;
        }
        .mermaid {
            margin: 2rem 0;
            text-align: center;
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
        }
    </style>
</head>
<body class="antialiased">
    <header class="bg-white sticky top-0 z-50 shadow-md">
        <nav class="container mx-auto px-4 sm:px-6 py-4 flex justify-between items-center">
            <div class="text-xl sm:text-2xl font-bold text-gray-800">
                <a href="../../../index.html" class="flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path></svg>
                    <span class="gradient-text">Data Engineering Concepts</span>
                </a>
            </div>
            <ul class="flex space-x-4 sm:space-x-6 text-gray-600 font-medium text-sm sm:text-base">
                <li><a href="../../../case_studies.html" class="hover:text-[#bc5090] font-semibold">Case Studies</a></li>
                <li><a href="../../../aboutme.html" class="hover:text-[#bc5090] font-semibold">About Me</a></li>
            </ul>
        </nav>
    </header>
    <main class="container mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <div class="content">
<h1 id="answer-key-idempotency-retry-semantics">Answer Key: Idempotency &amp; Retry Semantics</h1>
<p><a href="../../02-distributed-systems/idempotency-retries.html">Back to Exercises</a></p>
<hr />
<h2 id="exercise-1-design-idempotent-payment-api">Exercise 1: Design Idempotent Payment API</h2>
<p><strong>Question</strong>: Design an idempotent payment API. How do you ensure payments aren't charged twice?</p>
<h3 id="answer">Answer</h3>
<p><strong>Goal</strong>: Ensure that retrying a payment request doesn't charge the user twice.</p>
<h3 id="design-components">Design Components</h3>
<p><strong>1. Idempotency Key</strong></p>
<p><strong>Client generates unique key</strong>:
- <strong>Format</strong>: UUID v4 (random, unpredictable)
- <strong>Included in</strong>: Request header <code>Idempotency-Key: &lt;uuid&gt;</code>
- <strong>Scope</strong>: Per payment, unique per payment attempt</p>
<p><strong>Why UUID</strong>:
- Globally unique
- Unpredictable (can't be guessed)
- Standard format</p>
<p><strong>2. Server-Side Idempotency Check</strong></p>
<p><strong>Storage</strong>: Store idempotency keys in database or distributed cache (Redis)</p>
<p><strong>Process</strong>:
1. <strong>Receive request</strong>: Extract idempotency key from header
2. <strong>Check if key exists</strong>: Query storage for key
3. <strong>If exists</strong>: Return cached response (same payment ID, same status)
4. <strong>If not exists</strong>: Process payment, store result with key</p>
<p><strong>Storage schema</strong>:</p>
<pre><code>idempotency_keys:
  - key: UUID (primary key)
  - payment_id: UUID
  - status: string (pending, completed, failed)
  - amount: decimal
  - created_at: timestamp
  - expires_at: timestamp (TTL: 24 hours)
</code></pre>
<p><strong>3. Payment Processing</strong></p>
<p><strong>Idempotent flow</strong>:</p>
<div class="mermaid">
sequenceDiagram
participant Client
participant API
participant Storage
participant PaymentGateway
Client->>API: Payment Request + Idempotency Key
API->>Storage: Check if key exists
alt Key exists
Storage-->>API: Return cached result
API-->>Client: Return cached response
else Key doesn't exist
API->>Storage: Store key (status: pending)
API->>PaymentGateway: Process payment
alt Payment succeeds
PaymentGateway-->>API: Payment confirmed
API->>Storage: Update key (status: completed)
API-->>Client: Success response
else Payment fails
PaymentGateway-->>API: Payment failed
API->>Storage: Update key (status: failed)
API-->>Client: Error response
end
end
</div>
<p><strong>4. Handling Race Conditions</strong></p>
<p><strong>Problem</strong>: Two requests with same key arrive simultaneously.</p>
<p><strong>Solution</strong>: Use database transaction or distributed lock:
- <strong>Transaction</strong>: Check and insert atomically
- <strong>Distributed lock</strong>: Lock on idempotency key
- <strong>Optimistic locking</strong>: Use version numbers</p>
<p><strong>5. TTL and Cleanup</strong></p>
<p><strong>TTL</strong>: 24 hours (or based on business requirements)</p>
<p><strong>Why</strong>:
- Prevents storage from growing indefinitely
- Allows retries within reasonable time window
- Cleans up old keys automatically</p>
<p><strong>Cleanup</strong>:
- <strong>Automatic</strong>: Use Redis TTL or database expiration
- <strong>Manual</strong>: Periodic cleanup job for old keys</p>
<p><strong>6. Response Consistency</strong></p>
<p><strong>Important</strong>: Same idempotency key must return same response:
- Same payment ID
- Same status
- Same amount
- Same timestamp</p>
<p><strong>Why</strong>: Client may retry and expect same result.</p>
<h3 id="complete-api-design">Complete API Design</h3>
<p><strong>Endpoint</strong>: <code>POST /payments</code></p>
<p><strong>Request</strong>:</p>
<pre><code class="language-json">{
  &quot;amount&quot;: 100.00,
  &quot;currency&quot;: &quot;USD&quot;,
  &quot;payment_method&quot;: &quot;card_123&quot;,
  &quot;idempotency_key&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot;
}
</code></pre>
<p><strong>Headers</strong>:</p>
<pre><code>Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000
</code></pre>
<p><strong>Response</strong> (first request):</p>
<pre><code class="language-json">{
  &quot;payment_id&quot;: &quot;pay_123&quot;,
  &quot;status&quot;: &quot;completed&quot;,
  &quot;amount&quot;: 100.00,
  &quot;created_at&quot;: &quot;2024-01-01T12:00:00Z&quot;
}
</code></pre>
<p><strong>Response</strong> (retry with same key):</p>
<pre><code class="language-json">{
  &quot;payment_id&quot;: &quot;pay_123&quot;,  // Same payment ID
  &quot;status&quot;: &quot;completed&quot;,     // Same status
  &quot;amount&quot;: 100.00,          // Same amount
  &quot;created_at&quot;: &quot;2024-01-01T12:00:00Z&quot;  // Same timestamp
}
</code></pre>
<h3 id="answer_1">Answer</h3>
<p><strong>Idempotent payment API design</strong>:</p>
<ol>
<li><strong>Idempotency key</strong>: Client generates UUID, includes in request header</li>
<li><strong>Server-side check</strong>: Check if key exists in storage (Redis/database)</li>
<li><strong>If key exists</strong>: Return cached response (same payment ID, status)</li>
<li><strong>If key doesn't exist</strong>: Process payment, store result with key</li>
<li><strong>Race condition handling</strong>: Use transactions or distributed locks</li>
<li><strong>TTL</strong>: 24 hours (cleanup old keys)</li>
<li><strong>Response consistency</strong>: Same key returns same response</li>
</ol>
<p><strong>Key principles</strong>:
- <strong>Client generates key</strong>: Unpredictable UUID
- <strong>Server validates</strong>: Check before processing
- <strong>Store results</strong>: Cache response for retries
- <strong>Handle races</strong>: Use transactions/locks
- <strong>Consistent responses</strong>: Same key = same response</p>
<p><strong>Why this works</strong>:
- First request processes payment, stores result
- Retries return cached result (no duplicate charge)
- Race conditions handled with transactions
- TTL prevents storage growth</p>
<hr />
<h2 id="exercise-2-retry-strategy">Exercise 2: Retry Strategy</h2>
<p><strong>Question</strong>: Design a retry strategy for an API that calls a downstream service. What backoff do you use? What limits?</p>
<h3 id="answer_2">Answer</h3>
<p><strong>Goal</strong>: Retry failed requests intelligently without overwhelming downstream service.</p>
<h3 id="retry-strategy-components">Retry Strategy Components</h3>
<p><strong>1. Retryable Errors</strong></p>
<p><strong>Retry on</strong>:
- <strong>5xx errors</strong>: Server errors (500, 502, 503, 504)
- <strong>Timeouts</strong>: Connection timeout, request timeout
- <strong>Network errors</strong>: Connection refused, DNS errors</p>
<p><strong>Don't retry on</strong>:
- <strong>4xx errors</strong>: Client errors (400, 401, 403, 404)
- <strong>429 errors</strong>: Rate limited (may retry with longer backoff)
- <strong>Idempotency errors</strong>: Already processed</p>
<p><strong>2. Exponential Backoff</strong></p>
<p><strong>Formula</strong>: <code>wait_time = base_delay × 2^attempt + jitter</code></p>
<p><strong>Configuration</strong>:
- <strong>Base delay</strong>: 100ms
- <strong>Max delay</strong>: 10 seconds
- <strong>Jitter</strong>: Random 0-100ms</p>
<p><strong>Backoff schedule</strong>:
- Attempt 1: 100ms + jitter (0-100ms) = 100-200ms
- Attempt 2: 200ms + jitter (0-100ms) = 200-300ms
- Attempt 3: 400ms + jitter (0-100ms) = 400-500ms
- Attempt 4: 800ms + jitter (0-100ms) = 800-900ms
- Attempt 5: 1600ms + jitter (0-100ms) = 1600-1700ms (capped at 10s)</p>
<p><strong>Why exponential</strong>:
- Gives downstream service time to recover
- Reduces load on failing service
- Prevents thundering herd</p>
<p><strong>Why jitter</strong>:
- Spreads out retries from multiple clients
- Prevents synchronized retries
- Reduces thundering herd</p>
<p><strong>3. Retry Limits</strong></p>
<p><strong>Max retries</strong>: 3 (total 4 attempts: initial + 3 retries)</p>
<p><strong>Why limit retries</strong>:
- Prevents infinite retries
- Fails fast after reasonable attempts
- Reduces load on failing service</p>
<p><strong>Total time</strong>: ~3-4 seconds (with backoff)</p>
<p><strong>4. Circuit Breaker Integration</strong></p>
<p><strong>When circuit breaker opens</strong>:
- Don't retry (fail fast)
- Return error immediately
- Wait for circuit breaker to close</p>
<p><strong>Why</strong>: Prevents retrying when service is known to be down.</p>
<p><strong>5. Idempotency</strong></p>
<p><strong>Requirement</strong>: All operations must be idempotent.</p>
<p><strong>Why</strong>: Retries may execute operations multiple times.</p>
<p><strong>Implementation</strong>: Use idempotency keys (see Exercise 1).</p>
<h3 id="complete-retry-strategy">Complete Retry Strategy</h3>
<div class="mermaid">
flowchart TD
Request[Request] --> Call[Call Downstream]
Call --> Success{Success?}
Success -->|Yes| Return[Return Response]
Success -->|No| Check{Retryable?}
Check -->|No| Fail[Return Error]
Check -->|Yes| Attempt{Attempts < Max?}
Attempt -->|No| Fail
Attempt -->|Yes| Circuit{Circuit Open?}
Circuit -->|Yes| Fail
Circuit -->|No| Backoff[Exponential Backoff + Jitter]
Backoff --> Wait[Wait]
Wait --> Call
style Success fill:#99ff99
style Fail fill:#ff9999
style Backoff fill:#ffcc99
</div>
<p><strong>Configuration</strong>:
- <strong>Max retries</strong>: 3
- <strong>Base delay</strong>: 100ms
- <strong>Max delay</strong>: 10 seconds
- <strong>Jitter</strong>: 0-100ms random
- <strong>Retry on</strong>: 5xx, timeouts, network errors
- <strong>Don't retry on</strong>: 4xx (except 429), circuit breaker open</p>
<p><strong>Example</strong>:</p>
<pre><code>Attempt 1: Call downstream → 503 error
Wait: 100ms + 50ms jitter = 150ms
Attempt 2: Call downstream → 503 error
Wait: 200ms + 75ms jitter = 275ms
Attempt 3: Call downstream → 503 error
Wait: 400ms + 25ms jitter = 425ms
Attempt 4: Call downstream → 503 error
Return error (max retries exceeded)
</code></pre>
<h3 id="answer_3">Answer</h3>
<p><strong>Retry strategy</strong>:</p>
<ol>
<li><strong>Retryable errors</strong>: Retry on 5xx, timeouts, network errors</li>
<li><strong>Exponential backoff</strong>: Base 100ms, max 10s, with jitter</li>
<li><strong>Retry limits</strong>: Max 3 retries (4 total attempts)</li>
<li><strong>Circuit breaker</strong>: Don't retry when circuit open</li>
<li><strong>Idempotency</strong>: All operations must be idempotent</li>
</ol>
<p><strong>Backoff schedule</strong>:
- Attempt 1: 100-200ms
- Attempt 2: 200-300ms
- Attempt 3: 400-500ms
- Attempt 4: 800-900ms (if retrying 429)</p>
<p><strong>Total time</strong>: ~3-4 seconds maximum</p>
<p><strong>Key principles</strong>:
- <strong>Exponential backoff</strong>: Gives service time to recover
- <strong>Jitter</strong>: Prevents thundering herd
- <strong>Retry limits</strong>: Fails fast after reasonable attempts
- <strong>Circuit breaker</strong>: Prevents retrying when service down
- <strong>Idempotency</strong>: Safe to retry</p>
<hr />
<h2 id="exercise-3-handle-duplicates">Exercise 3: Handle Duplicates</h2>
<p><strong>Question</strong>: A non-idempotent operation is retried and creates duplicates. How do you detect and handle duplicates?</p>
<h3 id="answer_4">Answer</h3>
<p><strong>Problem</strong>: Non-idempotent operation was retried, creating duplicate records.</p>
<h3 id="detection-strategies">Detection Strategies</h3>
<p><strong>1. Unique Constraints</strong></p>
<p><strong>Database-level</strong>:
- Add unique constraint on identifying fields
- Database rejects duplicates automatically
- <strong>Example</strong>: Unique constraint on <code>(user_id, order_id)</code></p>
<p><strong>Pros</strong>: Simple, database enforces
<strong>Cons</strong>: Requires schema changes, may not catch all duplicates</p>
<p><strong>2. Deduplication Window</strong></p>
<p><strong>Process</strong>:
1. Hash request content + client identifier
2. Check if hash seen in time window (e.g., 24 hours)
3. If seen: Return previous result
4. If not seen: Process request, store hash</p>
<p><strong>Storage</strong>: Redis or database with TTL</p>
<p><strong>Hash components</strong>:
- Request content (body, parameters)
- Client identifier (user ID, API key)
- Operation type</p>
<p><strong>3. Timestamp-Based Detection</strong></p>
<p><strong>Process</strong>:
1. Include timestamp in request
2. Check for similar requests within time window
3. If found: Likely duplicate
4. If not found: Process request</p>
<p><strong>Time window</strong>: 5-10 minutes (typical retry window)</p>
<p><strong>4. Request ID Tracking</strong></p>
<p><strong>Process</strong>:
1. Client generates request ID
2. Server tracks processed request IDs
3. If ID seen: Return previous result
4. If ID not seen: Process request, store ID</p>
<p><strong>Storage</strong>: Redis with TTL (24 hours)</p>
<h3 id="handling-duplicates">Handling Duplicates</h3>
<p><strong>1. Reject Duplicates</strong></p>
<p><strong>Response</strong>: Return error indicating duplicate</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  &quot;error&quot;: &quot;duplicate_request&quot;,
  &quot;message&quot;: &quot;This request was already processed&quot;,
  &quot;original_request_id&quot;: &quot;req_123&quot;,
  &quot;original_timestamp&quot;: &quot;2024-01-01T12:00:00Z&quot;
}
</code></pre>
<p><strong>When to use</strong>: When duplicates are not acceptable (e.g., payments)</p>
<p><strong>2. Return Previous Result</strong></p>
<p><strong>Response</strong>: Return result from original request</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  &quot;request_id&quot;: &quot;req_123&quot;,
  &quot;status&quot;: &quot;completed&quot;,
  &quot;result&quot;: { ... },
  &quot;message&quot;: &quot;Duplicate request, returning previous result&quot;
}
</code></pre>
<p><strong>When to use</strong>: When operation is idempotent (e.g., creating user)</p>
<p><strong>3. Merge Duplicates</strong></p>
<p><strong>Process</strong>: Merge duplicate data intelligently</p>
<p><strong>Example</strong>: Two user creation requests → merge user data</p>
<p><strong>When to use</strong>: When duplicates can be merged (e.g., user profiles)</p>
<p><strong>4. Flag and Review</strong></p>
<p><strong>Process</strong>: Flag duplicates for manual review</p>
<p><strong>When to use</strong>: When automatic handling is risky (e.g., financial transactions)</p>
<h3 id="complete-solution">Complete Solution</h3>
<p><strong>Detection</strong>:
1. <strong>Unique constraints</strong>: Database-level enforcement
2. <strong>Deduplication window</strong>: Hash-based detection (24 hours)
3. <strong>Request ID tracking</strong>: Track processed request IDs
4. <strong>Timestamp checking</strong>: Check for similar requests in time window</p>
<p><strong>Handling</strong>:
1. <strong>Reject</strong>: Return error for duplicates
2. <strong>Return previous</strong>: Return cached result
3. <strong>Merge</strong>: Intelligently merge duplicate data
4. <strong>Flag</strong>: Flag for manual review</p>
<p><strong>Implementation</strong>:</p>
<pre><code class="language-python">def handle_request(request):
    # Generate deduplication key
    dedup_key = hash_request(request)

    # Check if seen before
    if redis.exists(dedup_key):
        previous_result = redis.get(dedup_key)
        return {
            &quot;status&quot;: &quot;duplicate&quot;,
            &quot;result&quot;: previous_result,
            &quot;message&quot;: &quot;Duplicate request, returning previous result&quot;
        }

    # Process request
    try:
        result = process_request(request)

        # Store result
        redis.setex(dedup_key, 86400, result)  # 24 hour TTL

        return result
    except DuplicateError:
        # Database unique constraint violation
        return {
            &quot;error&quot;: &quot;duplicate_request&quot;,
            &quot;message&quot;: &quot;This request was already processed&quot;
        }
</code></pre>
<h3 id="answer_5">Answer</h3>
<p><strong>Detect duplicates</strong>:</p>
<ol>
<li><strong>Unique constraints</strong>: Database-level enforcement on identifying fields</li>
<li><strong>Deduplication window</strong>: Hash request content + client ID, check in 24-hour window</li>
<li><strong>Request ID tracking</strong>: Track processed request IDs in Redis</li>
<li><strong>Timestamp checking</strong>: Check for similar requests within 5-10 minute window</li>
</ol>
<p><strong>Handle duplicates</strong>:</p>
<ol>
<li><strong>Reject</strong>: Return error for non-idempotent operations (e.g., payments)</li>
<li><strong>Return previous</strong>: Return cached result for idempotent operations</li>
<li><strong>Merge</strong>: Intelligently merge duplicate data when possible</li>
<li><strong>Flag</strong>: Flag for manual review when automatic handling is risky</li>
</ol>
<p><strong>Implementation</strong>:
- <strong>Storage</strong>: Redis with 24-hour TTL
- <strong>Hash</strong>: Request content + client ID + operation type
- <strong>Response</strong>: Return previous result or error based on operation type</p>
<p><strong>Key principles</strong>:
- <strong>Detect early</strong>: Check before processing
- <strong>Store results</strong>: Cache results for duplicate detection
- <strong>Handle appropriately</strong>: Different strategies for different operations
- <strong>TTL</strong>: Cleanup old deduplication keys</p>
<p><strong>Prevention</strong>:
- <strong>Make operations idempotent</strong>: Best solution (see Exercise 1)
- <strong>Use idempotency keys</strong>: Prevent duplicates at source
- <strong>Client-side deduplication</strong>: Don't retry if already succeeded</p>
        </div>
    </main>
    <footer class="bg-gray-800 text-white text-center p-6 mt-16">
        <p>&copy; 2025 Data Engineering Guides. An illustrative web application.</p>
    </footer>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
</body>
</html>
